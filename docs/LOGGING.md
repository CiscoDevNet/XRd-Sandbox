# Logging System Documentation

## Overview

The XRd Sandbox project includes a comprehensive logging system that automatically captures script execution logs in a structured, session-based format. This system handles color output intelligently and groups related operations together.

## Key Features

### 1. **Session-Based Logging**

All logs from a single `make` execution are grouped together in a timestamped directory:

```
logs/
├── 2025-12-18_14-30-45/
│   ├── segment-routing-deploy.log
│   └── create-configs.log
├── 2025-12-18_15-42-10/
│   ├── always-on-deploy.log
│   ├── inject-aaa.log
│   └── verify-deployment.log
```

### 2. **Automatic Color Management**

- **Development Mode**: Colors enabled for better readability in VS Code terminal
- **CI/CD Mode**: Colors automatically disabled when piping to files or running in pipelines
- **TTY Detection**: Automatically detects if output is going to a terminal or file

### 3. **Nested Make Targets**

When running composite targets like `make deploy-always-on`, all sub-steps share the same RUN_ID:

```
make deploy-always-on
└── logs/2025-12-18_14-30-45/
    ├── create-configs.log
    ├── inject-local-user.log
    ├── inject-aaa.log
    ├── inject-tacacs.log
    ├── generate-compose.log
    ├── start-containers.log
    └── verify-deployment.log
```

## Configuration

### Environment Variables

Located in `sandbox_env_vars.sh`:

```bash
# Enable color output (1 = enabled, 0 = disabled)
# Default: 0 (disabled for CI/CD compatibility)
ENABLE_COLOR=${ENABLE_COLOR:-0}

# Log directory base path
LOG_DIR=${SANDBOX_ROOT}/logs

# Run ID (auto-generated by Makefile)
RUN_ID=${RUN_ID:-}
```

### Enabling Colors for Development

For local development in VS Code, set the environment variable:

```bash
export ENABLE_COLOR=1
make deploy-segment-routing
```

Or create a `.env` file in the project root:

```bash
ENABLE_COLOR=1
```

The Makefile automatically includes `.env` if it exists.

## Usage in Scripts

### Basic Setup

1. **Source common utilities** (already done in existing scripts):

```bash
source "$SCRIPT_DIR/../lib/common.sh"
```

2. **Initialize logging at the start of your script**:

```bash
init_logging "my-script-name"
```

3. **Use logging functions**:

```bash
# Simple log message
log_message "Starting operation..."

# Execute command with automatic logging
log_exec "Deploying containers..." \
    docker compose up --detach

# Print and log together
print_info "Processing files..."
log_message "[INFO] Processing files..."
```

4. **Finalize logging at the end**:

```bash
finalize_logging
```

### Complete Example

```bash
#!/usr/bin/env bash

set -euo pipefail

# Source common utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/common.sh"

# Initialize logging
init_logging "my-deployment"

# Initialize environment
if ! init_sandbox_environment; then
    finalize_logging
    exit 1
fi

# Execute commands with logging
print_info "Starting deployment..."
log_message "Starting deployment..."

if ! log_exec "Creating configuration files..." \
    ./create-configs.sh; then
    finalize_logging
    exit 1
fi

print_success "Deployment complete!"
log_message "[SUCCESS] Deployment complete!"

# Finalize logging
finalize_logging
```

## Available Logging Functions

### `init_logging <script_name>`

Initializes logging for a script. Creates the log directory and file.

- **Parameters**: `script_name` - Name for the log file (without extension)
- **Returns**: 0 on success, 1 on failure

### `log_message <message>`

Writes a message to the log file (stripping color codes).

- **Parameters**: `message` - The message to log
- **Note**: Automatically strips ANSI color codes before writing

### `log_exec <description> <command> [args...]`

Executes a command while logging both the command and its output.

- **Parameters**:
  - `description` - Human-readable description of what the command does
  - `command` - The command to execute
  - `args...` - Command arguments
- **Returns**: The exit code of the command

### `finalize_logging`

Finalizes the log file with a timestamp and displays the log file path.

- **Note**: Always call this before script exit

### `print_info/success/warning/error <message>`

Display colored messages (existing functions, now color-aware).

- **Note**: Colors automatically disabled in non-TTY environments

## Log File Format

Each log file includes:

- **Header**: Timestamp, script name, and RUN_ID
- **Body**: Timestamped log entries (without color codes)
- **Footer**: End timestamp

Example log file content:

```
=== Log started at Wed Dec 18 14:30:45 PST 2025 ===
Script: segment-routing-deploy
RUN_ID: 2025-12-18_14-30-45
========================================

[INFO] Starting Segment Routing sandbox deployment...
[INFO] Using Docker image: ios-xr/xrd-control-plane:25.3.1
[INFO] Generating docker-compose.yml using xr-compose...
Command: xr-compose --input-file /home/developer/XRd-Sandbox/topologies/segment-routing/docker-compose.xr.yml --output-file /home/developer/XRd-Sandbox/topologies/segment-routing/docker-compose.yml --image ios-xr/xrd-control-plane:25.3.1
[SUCCESS] Completed: Generating docker-compose.yml using xr-compose...

========================================
=== Log ended at Wed Dec 18 14:31:22 PST 2025 ===
```

## CI/CD Integration

The logging system is designed to work seamlessly in CI/CD pipelines:

1. **Colors automatically disabled** when not running in a TTY
2. **Log files created** in `logs/<timestamp>/` directory
3. **Each run gets a unique directory** based on execution timestamp
4. **Structured output** makes it easy to parse logs

### Ansible Example

```yaml
- name: Deploy XRd Sandbox
  command: make deploy-segment-routing
  args:
    chdir: /path/to/XRd-Sandbox
  environment:
    ENABLE_COLOR: 0 # Explicitly disable colors (though auto-detected)
```

## Troubleshooting

### Colors appearing in log files

If you see ANSI escape codes in log files:

```
[33m[WARNING][0m Something happened
```

**Solution**: Ensure `ENABLE_COLOR` is not set to `1`, or let the system auto-detect TTY.

### Logs not being created

**Check**:

1. `SANDBOX_ROOT` is set correctly
2. The `logs/` directory is writable
3. `RUN_ID` is being generated by the Makefile

### All scripts logging to the same file

This happens if `init_logging` is called with the same script name. Ensure each script uses a unique name:

```bash
init_logging "my-unique-script-name"
```

## Best Practices

1. **Always call `init_logging`** at the start of scripts that need logging
2. **Always call `finalize_logging`** before exiting (including error exits)
3. **Use descriptive script names** for the log files
4. **Use `log_exec`** for important commands to capture their output
5. **Combine `print_*` and `log_message`** for user feedback and logging
6. **Keep `ENABLE_COLOR=0` as default** for maximum compatibility
7. **Review logs periodically** and clean up old log directories

## Migrating Existing Scripts

To add logging to existing scripts:

1. Add `init_logging` after sourcing common.sh:

   ```bash
   source "$SCRIPT_DIR/../lib/common.sh"
   init_logging "script-name"
   ```

2. Replace `run_command` calls with `log_exec`:

   ```bash
   # Before
   run_command "Description" command args

   # After
   log_exec "Description" command args
   ```

3. Add `log_message` calls for important events:

   ```bash
   print_info "Important event"
   log_message "[INFO] Important event"
   ```

4. Add `finalize_logging` before all exit points:

   ```bash
   finalize_logging
   exit 1
   ```

## Example: Full Script with Logging

See [scripts/deployment/segment-routing.sh](../scripts/deployment/segment-routing.sh) for a complete example of a script using the logging system.
